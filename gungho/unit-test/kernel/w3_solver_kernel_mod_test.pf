!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!
!-------------------------------------------------------------------------------
module w3_solver_kernel_mod_test

  use constants_mod,  only : i_def, r_def
  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: w3_solver_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type w3_solver_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(w3_solver_test_type), intent(inout) :: this

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(w3_solver_test_type), intent(inout) :: this

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_all( this )

    use w3_solver_kernel_mod, only: solver_w3_code

    use get_unit_test_q3x3x3_quadrature_mod, only:     &
            get_gaussian_q3x3x3_quadrature_points_xy,  &
            get_gaussian_q3x3x3_quadrature_points_z,   &
            get_gaussian_q3x3x3_quadrature_weights_xy, &
            get_gaussian_q3x3x3_quadrature_weights_z

    use get_unit_test_m3x3_q3x3x3_sizes_mod, only: get_w0_m3x3_q3x3x3_size

    implicit none

    class(w3_solver_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-14_r_def

    integer(i_def) :: ndf, map(1), undf
    real(kind=r_def) :: xdata(1)
    real(kind=r_def) :: rhsdata(1)
    real(kind=r_def) :: answer
    integer(i_def)   :: map_w0(8)
    real(kind=r_def) :: chi(8,3)
    real(kind=r_def) :: x_vert(8,3)
    real(kind=r_def) :: fx, fy, fz
    integer :: df, dim, qp1, qp2

    integer(i_def) :: ndf_chi, undf_chi

    real(r_def), allocatable :: basis(:,:,:,:)
    real(r_def), allocatable :: diff_basis(:,:,:,:)

    integer(i_def) :: nlayers
    integer(i_def) :: ndf_w0
    integer(i_def) :: undf_w0
    integer(i_def) :: ncells
    integer(i_def) :: dim_space
    integer(i_def) :: dim_space_diff
    integer(i_def) :: nqp_h
    integer(i_def) :: nqp_v

    real(r_def), allocatable :: wh(:)
    real(r_def), allocatable :: wv(:)
    real(r_def), allocatable :: xqp_h(:,:)
    real(r_def), allocatable :: xqp_v(:)

    !=====================================
    ! Get infrastructure support data
    !=====================================
    nlayers = 1

    call get_w0_m3x3_q3x3x3_size( ndf_w0, undf_w0, ncells,   &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v,              &
                                  nlayers )

    call get_gaussian_q3x3x3_quadrature_points_xy(xqp_h)
    call get_gaussian_q3x3x3_quadrature_points_z(xqp_v)
    call get_gaussian_q3x3x3_quadrature_weights_xy(wh)
    call get_gaussian_q3x3x3_quadrature_weights_z(wv)


    !=====================================
    ! Assign data for testing
    !=====================================
    ndf_chi  = ndf_w0
    undf_chi = undf_w0

    allocate( basis(1,8,nqp_h,nqp_v) )
    allocate( diff_basis(3,8,nqp_h,nqp_v) )

    x_vert(1,:) = (/ 0.0_r_def, 0.0_r_def, 0.0_r_def /)
    x_vert(2,:) = (/ 1.0_r_def, 0.0_r_def, 0.0_r_def /)
    x_vert(3,:) = (/ 1.0_r_def, 1.0_r_def, 0.0_r_def /)
    x_vert(4,:) = (/ 0.0_r_def, 1.0_r_def, 0.0_r_def /)
    x_vert(5,:) = (/ 0.0_r_def, 0.0_r_def, 1.0_r_def /)
    x_vert(6,:) = (/ 1.0_r_def, 0.0_r_def, 1.0_r_def /)
    x_vert(7,:) = (/ 1.0_r_def, 1.0_r_def, 1.0_r_def /)
    x_vert(8,:) = (/ 0.0_r_def, 1.0_r_def, 1.0_r_def /)

    ndf_w0 = 8
    do df = 1, ndf_w0
      map_w0(df) = df
      do qp2 = 1, nqp_v
        do qp1 = 1,nqp_h
          fx = (1.0_r_def - x_vert(df,1)) + (-1.0_r_def)**(int(x_vert(df,1))+1)*xqp_h(qp1,1)
          fy = (1.0_r_def - x_vert(df,2)) + (-1.0_r_def)**(int(x_vert(df,2))+1)*xqp_h(qp1,2)
          fz = (1.0_r_def - x_vert(df,3)) + (-1.0_r_def)**(int(x_vert(df,3))+1)*xqp_v(qp2)
          diff_basis(1,df,qp1,qp2) = fy*fz
          diff_basis(2,df,qp1,qp2) = fx*fz
          diff_basis(3,df,qp1,qp2) = fx*fy
        end do
      end do
      do dim = 1,3
        if ( x_vert(df,dim) < 1.0_r_def ) &
          diff_basis(dim,df,:,:) = -diff_basis(dim,df,:,:)
      end do
    end do
    chi(:,:) = x_vert(:,:)

    basis=1.0_r_def
    map(1)=1
    ndf=1
    undf=1
    rhsdata(1)=1.0_r_def
    undf_w0=8

    !=====================================
    ! Apply test
    !=====================================
    call solver_w3_code(nlayers,                               &
                        xdata, rhsdata,                        &
                        chi(:,1),chi(:,2),chi(:,3),            &
                        ndf, undf, map, basis,                 &
                        ndf_chi, undf_chi, map_w0, diff_basis, &
                        nqp_h, nqp_v, wh, wv )

! Answer for hardwired jacobian
!    answer = 1.0_r_def / ( 6000.0_r_def * 1000.0_r_def * 2000.0_r_def )
    answer = 1.0_r_def / ( 1.0_r_def * 1.0_r_def * 1.0_r_def )
    @assertEqual( answer, xdata(1), tol )

    deallocate( basis )
    deallocate( diff_basis )

    deallocate( wh )
    deallocate( wv )
    deallocate( xqp_h )
    deallocate( xqp_v )

  end subroutine test_all

end module w3_solver_kernel_mod_test
